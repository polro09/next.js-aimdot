<<<<<<< HEAD
const mongoose = require('mongoose');

// MongoDB Ïó∞Í≤∞ ÏÑ§Ï†ï
let isConnected = false;

const connectDB = async () => {
    if (isConnected) {
        console.log('üíæ Ïù¥ÎØ∏ MongoDBÏóê Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
        return;
    }

    try {
        const options = {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            maxPoolSize: 10, // Ïó∞Í≤∞ ÌíÄ ÏµúÎåÄ ÌÅ¨Í∏∞
            serverSelectionTimeoutMS: 5000, // ÏÑúÎ≤Ñ ÏÑ†ÌÉù ÌÉÄÏûÑÏïÑÏõÉ
            socketTimeoutMS: 45000, // ÏÜåÏºì ÌÉÄÏûÑÏïÑÏõÉ
            bufferMaxEntries: 0, // Î≤ÑÌçºÎßÅ ÎπÑÌôúÏÑ±Ìôî
        };

        await mongoose.connect(process.env.MONGO_URI, options);
        isConnected = true;
        console.log('‚úÖ MongoDB Ïó∞Í≤∞ ÏÑ±Í≥µ!');
    } catch (error) {
        console.error('‚ùå MongoDB Ïó∞Í≤∞ Ïã§Ìå®:', error.message);
        throw error;
    }
};

// Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
mongoose.connection.on('connected', () => {
    console.log('üì° MongoDB Ïó∞Í≤∞Îê®');
});

mongoose.connection.on('error', (err) => {
    console.error('üí• MongoDB Ïó∞Í≤∞ ÏóêÎü¨:', err);
});

mongoose.connection.on('disconnected', () => {
    console.log('üì¥ MongoDB Ïó∞Í≤∞ Ìï¥Ï†úÎê®');
    isConnected = false;
});

// Í∏∏Îìú(ÏÑúÎ≤Ñ) Ïä§ÌÇ§Îßà
const guildSchema = new mongoose.Schema({
    guildId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildName: {
        type: String,
        required: true
    },
    guildIcon: String,
    ownerId: String,
    memberCount: {
        type: Number,
        default: 0
    },
    settings: {
        prefix: {
            type: String,
            default: '!'
        },
        language: {
            type: String,
            default: 'ko'
        },
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        partyChannelId: String,
        logChannelId: String,
        welcomeChannelId: String,
        autoRole: String,
        partyNotificationRole: String,
        autoDeleteParties: {
            type: Boolean,
            default: true
        },
        requireApproval: {
            type: Boolean,
            default: false
        },
        maxPartiesPerUser: {
            type: Number,
            default: 5
        },
        partyDuration: {
            type: Number,
            default: 24 * 60 * 60 * 1000 // 24ÏãúÍ∞Ñ
        },
        allowAnonymousParties: {
            type: Boolean,
            default: false
        }
    },
    isActive: {
        type: Boolean,
        default: true
    },
    joinedAt: {
        type: Date,
        default: Date.now
    },
    lastActivity: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'guilds'
});

// ÏÇ¨Ïö©Ïûê Ïä§ÌÇ§Îßà
const userSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    username: {
        type: String,
        required: true
    },
    discriminator: String,
    avatar: String,
    email: String,
    locale: {
        type: String,
        default: 'ko'
    },
    settings: {
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        notifications: {
            partyInvites: {
                type: Boolean,
                default: true
            },
            partyUpdates: {
                type: Boolean,
                default: true
            },
            partyReminders: {
                type: Boolean,
                default: true
            },
            systemUpdates: {
                type: Boolean,
                default: true
            }
        },
        privacy: {
            showProfile: {
                type: Boolean,
                default: true
            },
            showStats: {
                type: Boolean,
                default: true
            },
            allowDM: {
                type: Boolean,
                default: true
            }
        }
    },
    stats: {
        partiesCreated: {
            type: Number,
            default: 0
        },
        partiesJoined: {
            type: Number,
            default: 0
        },
        partiesCompleted: {
            type: Number,
            default: 0
        },
        hoursPlayed: {
            type: Number,
            default: 0
        },
        lastActive: {
            type: Date,
            default: Date.now
        }
    },
    isActive: {
        type: Boolean,
        default: true
    },
    joinedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'users'
});

// Í≤åÏûÑ ÌååÌã∞ Ïä§ÌÇ§Îßà
const partySchema = new mongoose.Schema({
    partyId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    channelId: String,
    messageId: String,
    creatorId: {
        type: String,
        required: true,
        index: true
    },
    title: {
        type: String,
        required: true,
        maxlength: 100
    },
    description: {
        type: String,
        maxlength: 1000
    },
    game: {
        name: {
            type: String,
            required: true
        },
        type: String, // 'fps', 'mmorpg', 'moba', 'strategy', 'casual', etc.
        platform: String, // 'pc', 'mobile', 'console', 'cross-platform'
        imageUrl: String
    },
    schedule: {
        startTime: {
            type: Date,
            required: true
        },
        endTime: Date,
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        isRecurring: {
            type: Boolean,
            default: false
        },
        recurringPattern: String // 'daily', 'weekly', 'monthly'
    },
    participants: {
        max: {
            type: Number,
            required: true,
            min: 2,
            max: 50
        },
        current: [{
            userId: {
                type: String,
                required: true
            },
            username: String,
            joinedAt: {
                type: Date,
                default: Date.now
            },
            role: {
                type: String,
                enum: ['leader', 'member', 'substitute'],
                default: 'member'
            },
            status: {
                type: String,
                enum: ['confirmed', 'tentative', 'declined'],
                default: 'confirmed'
            }
        }],
        waitlist: [{
            userId: String,
            username: String,
            joinedAt: {
                type: Date,
                default: Date.now
            }
        }]
    },
    requirements: {
        minLevel: Number,
        maxLevel: Number,
        requiredRoles: [String],
        experience: {
            type: String,
            enum: ['beginner', 'intermediate', 'advanced', 'expert'],
            default: 'beginner'
        },
        voiceChat: {
            type: Boolean,
            default: false
        },
        ageRestriction: Number
    },
    status: {
        type: String,
        enum: ['open', 'full', 'started', 'completed', 'cancelled'],
        default: 'open',
        index: true
    },
    visibility: {
        type: String,
        enum: ['public', 'private', 'guild-only'],
        default: 'public'
    },
    tags: [String],
    notes: String,
    isActive: {
        type: Boolean,
        default: true
    },
    createdAt: {
        type: Date,
        default: Date.now,
        index: true
    },
    updatedAt: {
        type: Date,
        default: Date.now
    },
    completedAt: Date,
    cancelledAt: Date
}, {
    timestamps: true,
    collection: 'parties'
});

// Ïä§ÏºÄÏ§Ñ Ïä§ÌÇ§Îßà
const scheduleSchema = new mongoose.Schema({
    scheduleId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    creatorId: {
        type: String,
        required: true,
        index: true
    },
    title: {
        type: String,
        required: true,
        maxlength: 100
    },
    description: {
        type: String,
        maxlength: 500
    },
    type: {
        type: String,
        enum: ['event', 'tournament', 'meeting', 'raid', 'training', 'other'],
        default: 'event'
    },
    dateTime: {
        type: Date,
        required: true,
        index: true
    },
    duration: Number, // Î∂Ñ Îã®ÏúÑ
    timezone: {
        type: String,
        default: 'Asia/Seoul'
    },
    participants: [{
        userId: String,
        username: String,
        status: {
            type: String,
            enum: ['attending', 'maybe', 'not-attending'],
            default: 'attending'
        }
    }],
    reminders: [{
        time: Number, // Î∂Ñ Îã®ÏúÑ (Ïòà: 60 = 1ÏãúÍ∞Ñ Ï†Ñ)
        sent: {
            type: Boolean,
            default: false
        }
    }],
    isRecurring: {
        type: Boolean,
        default: false
    },
    recurringPattern: {
        type: String,
        enum: ['daily', 'weekly', 'monthly'],
    },
    recurringEnd: Date,
    status: {
        type: String,
        enum: ['scheduled', 'ongoing', 'completed', 'cancelled'],
        default: 'scheduled'
    },
    channelId: String,
    messageId: String,
    isActive: {
        type: Boolean,
        default: true
    }
}, {
    timestamps: true,
    collection: 'schedules'
});

// ÏÇ¨Ïö©Ïûê Í∂åÌïú Ïä§ÌÇ§Îßà
const userPermissionSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    permissions: {
        manageParties: {
            type: Boolean,
            default: false
        },
        manageSchedules: {
            type: Boolean,
            default: false
        },
        manageUsers: {
            type: Boolean,
            default: false
        },
        viewLogs: {
            type: Boolean,
            default: false
        },
        manageSettings: {
            type: Boolean,
            default: false
        },
        sendAnnouncements: {
            type: Boolean,
            default: false
        }
    },
    roles: [String], // Discord Ïó≠Ìï† ID Î™©Î°ù
    assignedBy: String,
    assignedAt: {
        type: Date,
        default: Date.now
    },
    expiresAt: Date,
    isActive: {
        type: Boolean,
        default: true
    }
}, {
    timestamps: true,
    collection: 'userPermissions'
});

// Î°úÍ∑∏ Ïä§ÌÇ§Îßà
const logSchema = new mongoose.Schema({
    logId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        index: true
    },
    userId: String,
    action: {
        type: String,
        required: true,
        index: true
    },
    details: mongoose.Schema.Types.Mixed,
    level: {
        type: String,
        enum: ['info', 'warn', 'error', 'debug'],
        default: 'info',
        index: true
    },
    timestamp: {
        type: Date,
        default: Date.now,
        index: true
    },
    ip: String,
    userAgent: String
}, {
    timestamps: true,
    collection: 'logs'
});

// Ïù∏Îç±Ïä§ ÏÉùÏÑ±
guildSchema.index({ guildId: 1 });
guildSchema.index({ isActive: 1 });
guildSchema.index({ lastActivity: -1 });

userSchema.index({ userId: 1 });
userSchema.index({ username: 1 });
userSchema.index({ 'stats.lastActive': -1 });

partySchema.index({ guildId: 1, status: 1 });
partySchema.index({ creatorId: 1, createdAt: -1 });
partySchema.index({ 'schedule.startTime': 1 });
partySchema.index({ status: 1, isActive: 1 });

scheduleSchema.index({ guildId: 1, dateTime: 1 });
scheduleSchema.index({ status: 1, isActive: 1 });

userPermissionSchema.index({ userId: 1, guildId: 1 }, { unique: true });

logSchema.index({ timestamp: -1 });
logSchema.index({ guildId: 1, timestamp: -1 });
logSchema.index({ action: 1, timestamp: -1 });

// TTL Ïù∏Îç±Ïä§ (ÏûêÎèô ÏÇ≠Ï†ú)
logSchema.index({ timestamp: 1 }, { expireAfterSeconds: 30 * 24 * 60 * 60 }); // 30Ïùº ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú

// Î™®Îç∏ ÏÉùÏÑ±
const Guild = mongoose.model('Guild', guildSchema);
const User = mongoose.model('User', userSchema);
const Party = mongoose.model('Party', partySchema);
const Schedule = mongoose.model('Schedule', scheduleSchema);
const UserPermission = mongoose.model('UserPermission', userPermissionSchema);
const Log = mongoose.model('Log', logSchema);

// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const DatabaseUtils = {
    // Í∏∏Îìú Ï¥àÍ∏∞Ìôî
    async initializeGuild(guildData) {
        try {
            const existingGuild = await Guild.findOne({ guildId: guildData.guildId });
            if (existingGuild) {
                // Í∏∞Ï°¥ Í∏∏Îìú Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                existingGuild.guildName = guildData.guildName;
                existingGuild.guildIcon = guildData.guildIcon;
                existingGuild.memberCount = guildData.memberCount;
                existingGuild.lastActivity = new Date();
                existingGuild.isActive = true;
                return await existingGuild.save();
            } else {
                // ÏÉà Í∏∏Îìú ÏÉùÏÑ±
                const newGuild = new Guild(guildData);
                return await newGuild.save();
            }
        } catch (error) {
            console.error('Í∏∏Îìú Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÏÇ¨Ïö©Ïûê Ï¥àÍ∏∞Ìôî
    async initializeUser(userData) {
        try {
            const existingUser = await User.findOne({ userId: userData.userId });
            if (existingUser) {
                // Í∏∞Ï°¥ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                existingUser.username = userData.username;
                existingUser.discriminator = userData.discriminator;
                existingUser.avatar = userData.avatar;
                existingUser.stats.lastActive = new Date();
                existingUser.isActive = true;
                return await existingUser.save();
            } else {
                // ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
                const newUser = new User(userData);
                return await newUser.save();
            }
        } catch (error) {
            console.error('ÏÇ¨Ïö©Ïûê Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÌååÌã∞ ÏÉùÏÑ±
    async createParty(partyData) {
        try {
            const party = new Party(partyData);
            return await party.save();
        } catch (error) {
            console.error('ÌååÌã∞ ÏÉùÏÑ± Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÌôúÏÑ± ÌååÌã∞ Ï°∞Ìöå
    async getActivePartiesByGuild(guildId) {
        try {
            return await Party.find({
                guildId,
                status: { $in: ['open', 'full', 'started'] },
                isActive: true
            }).sort({ createdAt: -1 });
        } catch (error) {
            console.error('ÌôúÏÑ± ÌååÌã∞ Ï°∞Ìöå Ïò§Î•ò:', error);
            throw error;
        }
    },

    // Î°úÍ∑∏ Í∏∞Î°ù
    async createLog(logData) {
        try {
            const log = new Log({
                ...logData,
                logId: `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            });
            return await log.save();
        } catch (error) {
            console.error('Î°úÍ∑∏ ÏÉùÏÑ± Ïò§Î•ò:', error);
            // Î°úÍ∑∏ ÏÉùÏÑ± Ïã§Ìå®Îäî Ï£ºÏöî Í∏∞Îä•Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÎèÑÎ°ù ÏóêÎü¨Î•º throwÌïòÏßÄ ÏïäÏùå
        }
    }
};

module.exports = {
    connectDB,
    Guild,
    User,
    Party,
    Schedule,
    UserPermission,
    Log,
    DatabaseUtils
=======
const mongoose = require('mongoose');

// MongoDB Ïó∞Í≤∞ ÏÑ§Ï†ï
let isConnected = false;

const connectDB = async () => {
    if (isConnected) {
        console.log('üíæ Ïù¥ÎØ∏ MongoDBÏóê Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
        return;
    }

    try {
        const options = {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            maxPoolSize: 10, // Ïó∞Í≤∞ ÌíÄ ÏµúÎåÄ ÌÅ¨Í∏∞
            serverSelectionTimeoutMS: 5000, // ÏÑúÎ≤Ñ ÏÑ†ÌÉù ÌÉÄÏûÑÏïÑÏõÉ
            socketTimeoutMS: 45000, // ÏÜåÏºì ÌÉÄÏûÑÏïÑÏõÉ
            bufferMaxEntries: 0, // Î≤ÑÌçºÎßÅ ÎπÑÌôúÏÑ±Ìôî
        };

        await mongoose.connect(process.env.MONGO_URI, options);
        isConnected = true;
        console.log('‚úÖ MongoDB Ïó∞Í≤∞ ÏÑ±Í≥µ!');
    } catch (error) {
        console.error('‚ùå MongoDB Ïó∞Í≤∞ Ïã§Ìå®:', error.message);
        throw error;
    }
};

// Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
mongoose.connection.on('connected', () => {
    console.log('üì° MongoDB Ïó∞Í≤∞Îê®');
});

mongoose.connection.on('error', (err) => {
    console.error('üí• MongoDB Ïó∞Í≤∞ ÏóêÎü¨:', err);
});

mongoose.connection.on('disconnected', () => {
    console.log('üì¥ MongoDB Ïó∞Í≤∞ Ìï¥Ï†úÎê®');
    isConnected = false;
});

// Í∏∏Îìú(ÏÑúÎ≤Ñ) Ïä§ÌÇ§Îßà
const guildSchema = new mongoose.Schema({
    guildId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildName: {
        type: String,
        required: true
    },
    guildIcon: String,
    ownerId: String,
    memberCount: {
        type: Number,
        default: 0
    },
    settings: {
        prefix: {
            type: String,
            default: '!'
        },
        language: {
            type: String,
            default: 'ko'
        },
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        partyChannelId: String,
        logChannelId: String,
        welcomeChannelId: String,
        autoRole: String,
        partyNotificationRole: String,
        autoDeleteParties: {
            type: Boolean,
            default: true
        },
        requireApproval: {
            type: Boolean,
            default: false
        },
        maxPartiesPerUser: {
            type: Number,
            default: 5
        },
        partyDuration: {
            type: Number,
            default: 24 * 60 * 60 * 1000 // 24ÏãúÍ∞Ñ
        },
        allowAnonymousParties: {
            type: Boolean,
            default: false
        }
    },
    isActive: {
        type: Boolean,
        default: true
    },
    joinedAt: {
        type: Date,
        default: Date.now
    },
    lastActivity: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'guilds'
});

// ÏÇ¨Ïö©Ïûê Ïä§ÌÇ§Îßà
const userSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    username: {
        type: String,
        required: true
    },
    discriminator: String,
    avatar: String,
    email: String,
    locale: {
        type: String,
        default: 'ko'
    },
    settings: {
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        notifications: {
            partyInvites: {
                type: Boolean,
                default: true
            },
            partyUpdates: {
                type: Boolean,
                default: true
            },
            partyReminders: {
                type: Boolean,
                default: true
            },
            systemUpdates: {
                type: Boolean,
                default: true
            }
        },
        privacy: {
            showProfile: {
                type: Boolean,
                default: true
            },
            showStats: {
                type: Boolean,
                default: true
            },
            allowDM: {
                type: Boolean,
                default: true
            }
        }
    },
    stats: {
        partiesCreated: {
            type: Number,
            default: 0
        },
        partiesJoined: {
            type: Number,
            default: 0
        },
        partiesCompleted: {
            type: Number,
            default: 0
        },
        hoursPlayed: {
            type: Number,
            default: 0
        },
        lastActive: {
            type: Date,
            default: Date.now
        }
    },
    isActive: {
        type: Boolean,
        default: true
    },
    joinedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'users'
});

// Í≤åÏûÑ ÌååÌã∞ Ïä§ÌÇ§Îßà
const partySchema = new mongoose.Schema({
    partyId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    channelId: String,
    messageId: String,
    creatorId: {
        type: String,
        required: true,
        index: true
    },
    title: {
        type: String,
        required: true,
        maxlength: 100
    },
    description: {
        type: String,
        maxlength: 1000
    },
    game: {
        name: {
            type: String,
            required: true
        },
        type: String, // 'fps', 'mmorpg', 'moba', 'strategy', 'casual', etc.
        platform: String, // 'pc', 'mobile', 'console', 'cross-platform'
        imageUrl: String
    },
    schedule: {
        startTime: {
            type: Date,
            required: true
        },
        endTime: Date,
        timezone: {
            type: String,
            default: 'Asia/Seoul'
        },
        isRecurring: {
            type: Boolean,
            default: false
        },
        recurringPattern: String // 'daily', 'weekly', 'monthly'
    },
    participants: {
        max: {
            type: Number,
            required: true,
            min: 2,
            max: 50
        },
        current: [{
            userId: {
                type: String,
                required: true
            },
            username: String,
            joinedAt: {
                type: Date,
                default: Date.now
            },
            role: {
                type: String,
                enum: ['leader', 'member', 'substitute'],
                default: 'member'
            },
            status: {
                type: String,
                enum: ['confirmed', 'tentative', 'declined'],
                default: 'confirmed'
            }
        }],
        waitlist: [{
            userId: String,
            username: String,
            joinedAt: {
                type: Date,
                default: Date.now
            }
        }]
    },
    requirements: {
        minLevel: Number,
        maxLevel: Number,
        requiredRoles: [String],
        experience: {
            type: String,
            enum: ['beginner', 'intermediate', 'advanced', 'expert'],
            default: 'beginner'
        },
        voiceChat: {
            type: Boolean,
            default: false
        },
        ageRestriction: Number
    },
    status: {
        type: String,
        enum: ['open', 'full', 'started', 'completed', 'cancelled'],
        default: 'open',
        index: true
    },
    visibility: {
        type: String,
        enum: ['public', 'private', 'guild-only'],
        default: 'public'
    },
    tags: [String],
    notes: String,
    isActive: {
        type: Boolean,
        default: true
    },
    createdAt: {
        type: Date,
        default: Date.now,
        index: true
    },
    updatedAt: {
        type: Date,
        default: Date.now
    },
    completedAt: Date,
    cancelledAt: Date
}, {
    timestamps: true,
    collection: 'parties'
});

// Ïä§ÏºÄÏ§Ñ Ïä§ÌÇ§Îßà
const scheduleSchema = new mongoose.Schema({
    scheduleId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    creatorId: {
        type: String,
        required: true,
        index: true
    },
    title: {
        type: String,
        required: true,
        maxlength: 100
    },
    description: {
        type: String,
        maxlength: 500
    },
    type: {
        type: String,
        enum: ['event', 'tournament', 'meeting', 'raid', 'training', 'other'],
        default: 'event'
    },
    dateTime: {
        type: Date,
        required: true,
        index: true
    },
    duration: Number, // Î∂Ñ Îã®ÏúÑ
    timezone: {
        type: String,
        default: 'Asia/Seoul'
    },
    participants: [{
        userId: String,
        username: String,
        status: {
            type: String,
            enum: ['attending', 'maybe', 'not-attending'],
            default: 'attending'
        }
    }],
    reminders: [{
        time: Number, // Î∂Ñ Îã®ÏúÑ (Ïòà: 60 = 1ÏãúÍ∞Ñ Ï†Ñ)
        sent: {
            type: Boolean,
            default: false
        }
    }],
    isRecurring: {
        type: Boolean,
        default: false
    },
    recurringPattern: {
        type: String,
        enum: ['daily', 'weekly', 'monthly'],
    },
    recurringEnd: Date,
    status: {
        type: String,
        enum: ['scheduled', 'ongoing', 'completed', 'cancelled'],
        default: 'scheduled'
    },
    channelId: String,
    messageId: String,
    isActive: {
        type: Boolean,
        default: true
    }
}, {
    timestamps: true,
    collection: 'schedules'
});

// ÏÇ¨Ïö©Ïûê Í∂åÌïú Ïä§ÌÇ§Îßà
const userPermissionSchema = new mongoose.Schema({
    userId: {
        type: String,
        required: true,
        index: true
    },
    guildId: {
        type: String,
        required: true,
        index: true
    },
    permissions: {
        manageParties: {
            type: Boolean,
            default: false
        },
        manageSchedules: {
            type: Boolean,
            default: false
        },
        manageUsers: {
            type: Boolean,
            default: false
        },
        viewLogs: {
            type: Boolean,
            default: false
        },
        manageSettings: {
            type: Boolean,
            default: false
        },
        sendAnnouncements: {
            type: Boolean,
            default: false
        }
    },
    roles: [String], // Discord Ïó≠Ìï† ID Î™©Î°ù
    assignedBy: String,
    assignedAt: {
        type: Date,
        default: Date.now
    },
    expiresAt: Date,
    isActive: {
        type: Boolean,
        default: true
    }
}, {
    timestamps: true,
    collection: 'userPermissions'
});

// Î°úÍ∑∏ Ïä§ÌÇ§Îßà
const logSchema = new mongoose.Schema({
    logId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    guildId: {
        type: String,
        index: true
    },
    userId: String,
    action: {
        type: String,
        required: true,
        index: true
    },
    details: mongoose.Schema.Types.Mixed,
    level: {
        type: String,
        enum: ['info', 'warn', 'error', 'debug'],
        default: 'info',
        index: true
    },
    timestamp: {
        type: Date,
        default: Date.now,
        index: true
    },
    ip: String,
    userAgent: String
}, {
    timestamps: true,
    collection: 'logs'
});

// Ïù∏Îç±Ïä§ ÏÉùÏÑ±
guildSchema.index({ guildId: 1 });
guildSchema.index({ isActive: 1 });
guildSchema.index({ lastActivity: -1 });

userSchema.index({ userId: 1 });
userSchema.index({ username: 1 });
userSchema.index({ 'stats.lastActive': -1 });

partySchema.index({ guildId: 1, status: 1 });
partySchema.index({ creatorId: 1, createdAt: -1 });
partySchema.index({ 'schedule.startTime': 1 });
partySchema.index({ status: 1, isActive: 1 });

scheduleSchema.index({ guildId: 1, dateTime: 1 });
scheduleSchema.index({ status: 1, isActive: 1 });

userPermissionSchema.index({ userId: 1, guildId: 1 }, { unique: true });

logSchema.index({ timestamp: -1 });
logSchema.index({ guildId: 1, timestamp: -1 });
logSchema.index({ action: 1, timestamp: -1 });

// TTL Ïù∏Îç±Ïä§ (ÏûêÎèô ÏÇ≠Ï†ú)
logSchema.index({ timestamp: 1 }, { expireAfterSeconds: 30 * 24 * 60 * 60 }); // 30Ïùº ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú

// Î™®Îç∏ ÏÉùÏÑ±
const Guild = mongoose.model('Guild', guildSchema);
const User = mongoose.model('User', userSchema);
const Party = mongoose.model('Party', partySchema);
const Schedule = mongoose.model('Schedule', scheduleSchema);
const UserPermission = mongoose.model('UserPermission', userPermissionSchema);
const Log = mongoose.model('Log', logSchema);

// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const DatabaseUtils = {
    // Í∏∏Îìú Ï¥àÍ∏∞Ìôî
    async initializeGuild(guildData) {
        try {
            const existingGuild = await Guild.findOne({ guildId: guildData.guildId });
            if (existingGuild) {
                // Í∏∞Ï°¥ Í∏∏Îìú Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                existingGuild.guildName = guildData.guildName;
                existingGuild.guildIcon = guildData.guildIcon;
                existingGuild.memberCount = guildData.memberCount;
                existingGuild.lastActivity = new Date();
                existingGuild.isActive = true;
                return await existingGuild.save();
            } else {
                // ÏÉà Í∏∏Îìú ÏÉùÏÑ±
                const newGuild = new Guild(guildData);
                return await newGuild.save();
            }
        } catch (error) {
            console.error('Í∏∏Îìú Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÏÇ¨Ïö©Ïûê Ï¥àÍ∏∞Ìôî
    async initializeUser(userData) {
        try {
            const existingUser = await User.findOne({ userId: userData.userId });
            if (existingUser) {
                // Í∏∞Ï°¥ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
                existingUser.username = userData.username;
                existingUser.discriminator = userData.discriminator;
                existingUser.avatar = userData.avatar;
                existingUser.stats.lastActive = new Date();
                existingUser.isActive = true;
                return await existingUser.save();
            } else {
                // ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
                const newUser = new User(userData);
                return await newUser.save();
            }
        } catch (error) {
            console.error('ÏÇ¨Ïö©Ïûê Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÌååÌã∞ ÏÉùÏÑ±
    async createParty(partyData) {
        try {
            const party = new Party(partyData);
            return await party.save();
        } catch (error) {
            console.error('ÌååÌã∞ ÏÉùÏÑ± Ïò§Î•ò:', error);
            throw error;
        }
    },

    // ÌôúÏÑ± ÌååÌã∞ Ï°∞Ìöå
    async getActivePartiesByGuild(guildId) {
        try {
            return await Party.find({
                guildId,
                status: { $in: ['open', 'full', 'started'] },
                isActive: true
            }).sort({ createdAt: -1 });
        } catch (error) {
            console.error('ÌôúÏÑ± ÌååÌã∞ Ï°∞Ìöå Ïò§Î•ò:', error);
            throw error;
        }
    },

    // Î°úÍ∑∏ Í∏∞Î°ù
    async createLog(logData) {
        try {
            const log = new Log({
                ...logData,
                logId: `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            });
            return await log.save();
        } catch (error) {
            console.error('Î°úÍ∑∏ ÏÉùÏÑ± Ïò§Î•ò:', error);
            // Î°úÍ∑∏ ÏÉùÏÑ± Ïã§Ìå®Îäî Ï£ºÏöî Í∏∞Îä•Ïóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÎèÑÎ°ù ÏóêÎü¨Î•º throwÌïòÏßÄ ÏïäÏùå
        }
    }
};

module.exports = {
    connectDB,
    Guild,
    User,
    Party,
    Schedule,
    UserPermission,
    Log,
    DatabaseUtils
>>>>>>> 3b599428ec14d20c82b0789575df317f455352b8
};